<haxe>
	<class path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="haxe.remoting.AsyncConnection" params="" file="/usr/lib/haxe/std/haxe/remoting/AsyncConnection.hx" interface="1">
		<resolve public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<call public="1" set="method"><f a="params:?result">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></call>
		<setErrorHandler public="1" set="method"><f a="error">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="org.zeromq.remoting.ZMQConnection" params="" file="./org/zeromq/remoting/ZMQConnection.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<create public="1" set="method" line="150" static="1"><f a="s:?ctx">
	<c path="org.zeromq.ZMQSocket"/>
	<c path="haxe.remoting.Context"/>
	<c path="org.zeromq.remoting.ZMQConnection"/>
</f></create>
		<__path><c path="Array"><c path="String"/></c></__path>
		<__data><a>
	<results><c path="List"><a>
	<onResult><f a="">
	<d/>
	<e path="Void"/>
</f></onResult>
	<onError><f a="">
	<d/>
	<e path="Void"/>
</f></onError>
</a></c></results>
	<protocol><c path="org.zeromq.remoting.ZMQSocketProtocol"/></protocol>
	<log><f a="::">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
	<e path="Void"/>
</f></log>
	<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
</a></__data>
		<resolve public="1" set="method" line="74"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<call public="1" set="method" line="80"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></call>
		<setErrorHandler public="1" set="method" line="89"><f a="h">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
		<setErrorLogger public="1" set="method" line="93"><f a="h">
	<f a="::">
		<c path="Array"><c path="String"/></c>
		<c path="Array"><d/></c>
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorLogger>
		<setProtocol public="1" set="method" line="97"><f a="p">
	<c path="org.zeromq.remoting.ZMQSocketProtocol"/>
	<e path="Void"/>
</f></setProtocol>
		<getProtocol public="1" set="method" line="101"><f a=""><c path="org.zeromq.remoting.ZMQSocketProtocol"/></f></getProtocol>
		<close public="1" set="method" line="105"><f a=""><e path="Void"/></f></close>
		<processMessage public="1" set="method" line="109"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></processMessage>
		<defaultLog set="method" line="141"><f a="path:args:e">
	<a><join set="null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></join></a>
	<a><join set="null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></join></a>
	<unknown/>
	<e path="Void"/>
</f></defaultLog>
		<new set="method" line="69"><f a="data:path">
	<a>
		<results><c path="List"><a>
	<onResult><f a="">
	<d/>
	<e path="Void"/>
</f></onResult>
	<onError><f a="">
	<d/>
	<e path="Void"/>
</f></onError>
</a></c></results>
		<protocol><c path="org.zeromq.remoting.ZMQSocketProtocol"/></protocol>
		<log><f a="::">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
	<e path="Void"/>
</f></log>
		<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
	</a>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * This class provides a haXe remoting adapter using the zeroMQ message 
 * library (via hxzmq) as the transport layer.
 * 
 * <pre>
 * 
 * </pre>
 ]]></haxe_doc>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<enum path="org.zeromq.SocketType" params="" file="./org/zeromq/ZMQ.hx" module="org.zeromq.ZMQ">
		<ZMQ_SUB/>
		<ZMQ_ROUTER/>
		<ZMQ_REQ/>
		<ZMQ_REP/>
		<ZMQ_PUSH/>
		<ZMQ_PULL/>
		<ZMQ_PUB/>
		<ZMQ_PAIR/>
		<ZMQ_DEALER/>
		<haxe_doc>
 * Enumeration of 0MQ socket types
 </haxe_doc>
	</enum>
	<enum path="org.zeromq.ErrorType" params="" file="./org/zeromq/ZMQ.hx" module="org.zeromq.ZMQ">
		<ETERM/>
		<EPROTONOSUPPORT/>
		<ENOTSUP/>
		<ENOMEM/>
		<ENODEV/>
		<ENOCOMPATPROTO/>
		<ENOBUFS/>
		<ENETDOWN/>
		<EMTHREAD/>
		<EINVAL/>
		<EINPROGRESS/>
		<EFSM/>
		<ECONNREFUSED/>
		<EAGAIN/>
		<EADDRNOTAVAIL/>
		<EADDRINUSE/>
		<haxe_doc>
 * Enumeration of 0MQ error types
 </haxe_doc>
	</enum>
	<enum path="org.zeromq.SendReceiveFlagType" params="" file="./org/zeromq/ZMQ.hx" module="org.zeromq.ZMQ">
		<SNDMORE/>
		<DONTWAIT/>
		<haxe_doc>
 * Enumeration of 0MQ send and receive flags
 </haxe_doc>
	</enum>
	<enum path="org.zeromq.SocketOptionsType" params="" file="./org/zeromq/ZMQ.hx" module="org.zeromq.ZMQ">
		<ZMQ_UNSUBSCRIBE/>
		<ZMQ_TYPE/>
		<ZMQ_SWAP/>
		<ZMQ_SUBSCRIBE/>
		<ZMQ_SNDBUF/>
		<ZMQ_RECOVERY_IVL_MSEC/>
		<ZMQ_RECOVERY_IVL/>
		<ZMQ_RECONNECT_IVL_MAX/>
		<ZMQ_RECONNECT_IVL/>
		<ZMQ_RCVMORE/>
		<ZMQ_RCVBUF/>
		<ZMQ_RATE/>
		<ZMQ_MCAST_LOOP/>
		<ZMQ_LINGER/>
		<ZMQ_IDENTITY/>
		<ZMQ_HWM/>
		<ZMQ_FD/>
		<ZMQ_EVENTS/>
		<ZMQ_BACKLOG/>
		<ZMQ_AFFINITY/>
		<haxe_doc>
 * Enumeration of 0MQ socket types
 * See: http://api.zeromq.org/master:zmq-setsockopt
 </haxe_doc>
	</enum>
	<enum path="org.zeromq.DeviceType" params="" file="./org/zeromq/ZMQ.hx" module="org.zeromq.ZMQ">
		<ZMQ_STREAMER/>
		<ZMQ_QUEUE/>
		<ZMQ_FORWARDER/>
	</enum>
	<typedef path="org.zeromq.ZMQInt64Type" params="" file="./org/zeromq/ZMQ.hx" module="org.zeromq.ZMQ">
		<a>
			<lo><c path="Int"/></lo>
			<hi><c path="Int"/></hi>
		</a>
		<haxe_doc>
 * Used to pass 64 bit ints to setlongsockopt
 </haxe_doc>
	</typedef>
	<class path="cpp.Lib" params="" file="/usr/lib/haxe/std/cpp/Lib.hx">
		<load public="1" set="method" line="32" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
		Load and return a Cpp primitive from a DLL library.
	</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="44" static="1">
			<f a="lib:prim:nargs">
				<unknown/>
				<unknown/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
		Tries to load, and always returns a valid function, but the function may throw
		if called.
	</haxe_doc>
		</loadLazy>
		<rethrow public="1" set="method" line="59" static="1"><f a="inExp">
	<d/>
	<e path="Void"/>
</f></rethrow>
		<stringReference public="1" set="method" line="61" static="1"><f a="inExp">
	<d/>
	<e path="Void"/>
</f></stringReference>
		<print public="1" set="method" line="66" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output.
	</haxe_doc>
		</print>
		<haxeToNeko public="1" set="method" line="74" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic
	</haxe_doc>
		</haxeToNeko>
		<nekoToHaxe public="1" set="method" line="82" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic
	</haxe_doc>
		</nekoToHaxe>
		<println public="1" set="method" line="88" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output followed by a newline character.
	</haxe_doc>
		</println>
	</class>
	<class path="org.zeromq.ZMQ" params="" file="./org/zeromq/ZMQ.hx">
		<bytesSocketOptionTypes public="1" line="118" static="1"><c path="Array"><e path="org.zeromq.SocketOptionsType"/></c></bytesSocketOptionTypes>
		<int64SocketOptionTypes public="1" line="124" static="1"><c path="Array"><e path="org.zeromq.SocketOptionsType"/></c></int64SocketOptionTypes>
		<intSocketOptionTypes public="1" line="138" static="1"><c path="Array"><e path="org.zeromq.SocketOptionsType"/></c></intSocketOptionTypes>
		<ZMQ_POLLIN public="1" get="inline" set="null" line="152" static="1"><f a=""><c path="Int"/></f></ZMQ_POLLIN>
		<ZMQ_POLLOUT public="1" get="inline" set="null" line="155" static="1"><f a=""><c path="Int"/></f></ZMQ_POLLOUT>
		<ZMQ_POLLERR public="1" get="inline" set="null" line="158" static="1"><f a=""><c path="Int"/></f></ZMQ_POLLERR>
		<version_full public="1" set="method" line="166" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Gets complete 0MQ library version 
	 * @return		0MQ library version in form MMmmpp (MM=major, mm=minor, pp=patch)
	 </haxe_doc>
		</version_full>
		<versionMajor public="1" set="method" line="175" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Gets 0MQ library major version
	 * @return		0MQ major library version (2, 3 etc)
	 </haxe_doc>
		</versionMajor>
		<versionMinor public="1" set="method" line="184" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Gets 0MQ library minor version
	 * @return		0MQ minor library version
	 </haxe_doc>
		</versionMinor>
		<versionPatch public="1" set="method" line="193" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Gets 0MQ library patch version
	 * @return		0MQ library patch version
	 </haxe_doc>
		</versionPatch>
		<makeVersion public="1" set="method" line="205" static="1">
			<f a="major:minor:patch">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Creates an integer in same form as given by versionFull()
	 * @param	major
	 * @param	minor
	 * @param	patch
	 * @return
	 </haxe_doc>
		</makeVersion>
		<strError public="1" set="method" line="216" static="1">
			<f a="e">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Returns a human-readable description from a ZMQException object errNo number
	 * @param	errNo		A valid 0MQ error number.
	 * 						Use the errorTypeToErrNo method to convert a ZMQ.ErrorType
	 * @return				A short description of the error
	 </haxe_doc>
		</strError>
		<socketTypeNo public="1" set="method" line="230" static="1">
			<f a="type">
				<e path="org.zeromq.SocketType"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Converts a SocketType enum into a ZMQ socket type integer value
	 * @param	type
	 * @return
	 </haxe_doc>
		</socketTypeNo>
		<socketOptionTypeNo public="1" set="method" line="262" static="1">
			<f a="option">
				<e path="org.zeromq.SocketOptionsType"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Converts a SocketOptionsType enum into a ZMQ int
	 * @param	option
	 * @return
	 </haxe_doc>
		</socketOptionTypeNo>
		<sendReceiveFlagNo public="1" set="method" line="316" static="1">
			<f a="type">
				<e path="org.zeromq.SendReceiveFlagType"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Converts a SendReceiveFlagType enum value into the corresponding 0MQ library int value
	 * @param	type
	 * @return
	 </haxe_doc>
		</sendReceiveFlagNo>
		<errorTypeToErrNo public="1" set="method" line="335" static="1">
			<f a="e">
				<e path="org.zeromq.ErrorType"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Converts Haxe ErrorType enum value to ZMQ errNo integer value
	 * @param	e
	 * @return
	 </haxe_doc>
		</errorTypeToErrNo>
		<errNoToErrorType public="1" set="method" line="381" static="1">
			<f a="e">
				<c path="Int"/>
				<e path="org.zeromq.ErrorType"/>
			</f>
			<haxe_doc>
	 * Converts ZMQ errNo integer value to Haxe ErrorType enum value
	 * @param	e
	 * @return
	 </haxe_doc>
		</errNoToErrorType>
		<deviceTypeToDevice public="1" set="method" line="428" static="1">
			<f a="device">
				<e path="org.zeromq.DeviceType"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Converts a ZMQ DeviceType enum value into underlying device number.
	 * Used for call to zmq_device
	 * @param	device
	 * @return
	 </haxe_doc>
		</deviceTypeToDevice>
		<catchSignals public="1" set="method" line="447" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Sets up interrupt signal handling.
	 * Use isInterrupted() to subsequently test for interruption
	 </haxe_doc>
		</catchSignals>
		<isInterrupted public="1" set="method" line="459" static="1">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Indicates if 0MQ has been interrupted by a system signal (SIGINT or SIGTERM)
	 * Use this method to detect interrupt, and exit cleanly (close 0MQ sockets and contexts),
	 * particularly after recvMsg() and poll() calls.
	 * See: http://zguide.zeromq.org/page:all#Handling-Interrupt-Signals
	 * 
	 * @return		True if 0MQ has been interrupted
	 </haxe_doc>
		</isInterrupted>
		<_hx_zmq_version_full line="466" static="1"><f a=""><c path="Int"/></f></_hx_zmq_version_full>
		<_hx_zmq_version_major line="467" static="1"><f a=""><c path="Int"/></f></_hx_zmq_version_major>
		<_hx_zmq_version_minor line="468" static="1"><f a=""><c path="Int"/></f></_hx_zmq_version_minor>
		<_hx_zmq_version_patch line="469" static="1"><f a=""><c path="Int"/></f></_hx_zmq_version_patch>
		<_hx_zmq_make_version line="470" static="1"><f a="::">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></_hx_zmq_make_version>
		<_hx_zmq_str_error line="471" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></_hx_zmq_str_error>
		<_hx_zmq_catch_signals line="472" static="1"><f a=""><unknown/></f></_hx_zmq_catch_signals>
		<_hx_zmq_interrupted line="473" static="1"><f a=""><c path="Int"/></f></_hx_zmq_interrupted>
		<_hx_zmq_ZMQ_PUB line="475" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_PUB>
		<_hx_zmq_ZMQ_SUB line="476" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_SUB>
		<_hx_zmq_ZMQ_PAIR line="477" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_PAIR>
		<_hx_zmq_ZMQ_REQ line="478" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_REQ>
		<_hx_zmq_ZMQ_REP line="479" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_REP>
		<_hx_zmq_ZMQ_DEALER line="480" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_DEALER>
		<_hx_zmq_ZMQ_ROUTER line="481" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_ROUTER>
		<_hx_zmq_ZMQ_PULL line="482" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_PULL>
		<_hx_zmq_ZMQ_PUSH line="483" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_PUSH>
		<_hx_zmq_ZMQ_LINGER line="485" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_LINGER>
		<_hx_zmq_ZMQ_HWM line="486" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_HWM>
		<_hx_zmq_ZMQ_RCVMORE line="487" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_RCVMORE>
		<_hx_zmq_ZMQ_SUBSCRIBE line="488" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_SUBSCRIBE>
		<_hx_zmq_ZMQ_UNSUBSCRIBE line="489" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_UNSUBSCRIBE>
		<_hx_zmq_ZMQ_SWAP line="490" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_SWAP>
		<_hx_zmq_ZMQ_AFFINITY line="491" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_AFFINITY>
		<_hx_zmq_ZMQ_IDENTITY line="492" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_IDENTITY>
		<_hx_zmq_ZMQ_RATE line="494" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_RATE>
		<_hx_zmq_ZMQ_RECOVERY_IVL line="495" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_RECOVERY_IVL>
		<_hx_zmq_ZMQ_RECOVERY_IVL_MSEC line="496" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_RECOVERY_IVL_MSEC>
		<_hx_zmq_ZMQ_MCAST_LOOP line="497" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_MCAST_LOOP>
		<_hx_zmq_ZMQ_SNDBUF line="498" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_SNDBUF>
		<_hx_zmq_ZMQ_RCVBUF line="499" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_RCVBUF>
		<_hx_zmq_ZMQ_RECONNECT_IVL line="500" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_RECONNECT_IVL>
		<_hx_zmq_ZMQ_RECONNECT_IVL_MAX line="501" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_RECONNECT_IVL_MAX>
		<_hx_zmq_ZMQ_BACKLOG line="502" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_BACKLOG>
		<_hx_zmq_ZMQ_FD line="503" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_FD>
		<_hx_zmq_ZMQ_EVENTS line="504" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_EVENTS>
		<_hx_zmq_ZMQ_TYPE line="505" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_ZMQ_TYPE>
		<_hx_zmq_ZMQ_POLLIN line="507" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ZMQ_POLLIN>
		<_hx_zmq_ZMQ_POLLOUT line="508" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ZMQ_POLLOUT>
		<_hx_zmq_ZMQ_POLLERR line="509" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ZMQ_POLLERR>
		<_hx_zmq_DONTWAIT line="511" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_DONTWAIT>
		<_hx_zmq_SNDMORE line="512" static="1"><f a=""><t path="Null"><c path="Int"/></t></f></_hx_zmq_SNDMORE>
		<_hx_zmq_EINVAL line="514" static="1"><f a=""><c path="Int"/></f></_hx_zmq_EINVAL>
		<_hx_zmq_ENOTSUP line="515" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ENOTSUP>
		<_hx_zmq_EPROTONOSUPPORT line="516" static="1"><f a=""><c path="Int"/></f></_hx_zmq_EPROTONOSUPPORT>
		<_hx_zmq_EAGAIN line="517" static="1"><f a=""><c path="Int"/></f></_hx_zmq_EAGAIN>
		<_hx_zmq_ENOMEM line="518" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ENOMEM>
		<_hx_zmq_ENODEV line="519" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ENODEV>
		<_hx_zmq_ENOBUFS line="520" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ENOBUFS>
		<_hx_zmq_ENETDOWN line="521" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ENETDOWN>
		<_hx_zmq_EADDRINUSE line="522" static="1"><f a=""><c path="Int"/></f></_hx_zmq_EADDRINUSE>
		<_hx_zmq_EADDRNOTAVAIL line="523" static="1"><f a=""><c path="Int"/></f></_hx_zmq_EADDRNOTAVAIL>
		<_hx_zmq_ECONNREFUSED line="524" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ECONNREFUSED>
		<_hx_zmq_EINPROGRESS line="525" static="1"><f a=""><c path="Int"/></f></_hx_zmq_EINPROGRESS>
		<_hx_zmq_EMTHREAD line="526" static="1"><f a=""><c path="Int"/></f></_hx_zmq_EMTHREAD>
		<_hx_zmq_EFSM line="527" static="1"><f a=""><c path="Int"/></f></_hx_zmq_EFSM>
		<_hx_zmq_ENOCOMPATPROTO line="528" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ENOCOMPATPROTO>
		<_hx_zmq_ETERM line="529" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ETERM>
		<_hx_zmq_ZMQ_QUEUE line="531" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ZMQ_QUEUE>
		<_hx_zmq_ZMQ_FORWARDER line="532" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ZMQ_FORWARDER>
		<_hx_zmq_ZMQ_STREAMER line="533" static="1"><f a=""><c path="Int"/></f></_hx_zmq_ZMQ_STREAMER>
		<haxe_doc>
 * Core class for 0MQ Haxe bindings
 </haxe_doc>
	</class>
	<typedef path="cpp.io.FileHandle" params="" file="/usr/lib/haxe/std/cpp/io/File.hx" module="cpp.io.File"><d/></typedef>
	<enum path="cpp.io.FileSeek" params="" file="/usr/lib/haxe/std/cpp/io/File.hx" module="cpp.io.File">
		<SeekEnd/>
		<SeekCur/>
		<SeekBegin/>
	</enum>
	<class path="cpp.io.File" params="" file="/usr/lib/haxe/std/cpp/io/File.hx">
		<getContent public="1" set="method" line="40" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<getBytes public="1" set="method" line="45" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<read public="1" set="method" line="50" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="cpp.io.FileInput"/>
</f></read>
		<write public="1" set="method" line="54" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="cpp.io.FileOutput"/>
</f></write>
		<append public="1" set="method" line="58" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="cpp.io.FileOutput"/>
</f></append>
		<copy public="1" set="method" line="62" static="1"><f a="src:dst">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></copy>
		<stdin public="1" set="method" line="70" static="1"><f a=""><c path="cpp.io.FileInput"/></f></stdin>
		<stdout public="1" set="method" line="74" static="1"><f a=""><c path="cpp.io.FileOutput"/></f></stdout>
		<stderr public="1" set="method" line="78" static="1"><f a=""><c path="cpp.io.FileOutput"/></f></stderr>
		<getChar public="1" set="method" line="82" static="1"><f a="echo">
	<e path="Bool"/>
	<c path="Int"/>
</f></getChar>
		<file_stdin line="86" static="1"><f a=""><t path="cpp.io.FileHandle"/></f></file_stdin>
		<file_stdout line="87" static="1"><f a=""><t path="cpp.io.FileHandle"/></f></file_stdout>
		<file_stderr line="88" static="1"><f a=""><t path="cpp.io.FileHandle"/></f></file_stderr>
		<file_contents line="90" static="1"><f a="">
	<c path="String"/>
	<t path="haxe.io.BytesData"/>
</f></file_contents>
		<file_open line="91" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<t path="cpp.io.FileHandle"/>
</f></file_open>
		<getch line="93" static="1"><f a="">
	<e path="Bool"/>
	<c path="Int"/>
</f></getch>
		<haxe_doc>
	API for reading and writing to files.
</haxe_doc>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><t path="haxe.io.BytesData"/></b>
		<addByte public="1" get="inline" set="null" line="55"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="69"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addBytes public="1" get="inline" set="null" line="84"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="106">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>
		Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.
	</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.zeromq.ZThread" params="" file="./org/zeromq/ZThread.hx">
		<attachedShim_fn set="method" line="37" static="1"><f a="thread_fn:ctx:pipe:args">
	<f a="::">
		<c path="org.zeromq.ZContext"/>
		<c path="org.zeromq.ZMQSocket"/>
		<d/>
		<e path="Void"/>
	</f>
	<c path="org.zeromq.ZContext"/>
	<c path="org.zeromq.ZMQSocket"/>
	<d/>
	<e path="Void"/>
</f></attachedShim_fn>
		<detach public="1" set="method" line="48" static="1">
			<f a="thread_fn:args">
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Create a detached thread (or forked process for php). A detached thread operates autonomously
	 * and is used to simulate a separate process. It gets no ctx or pipe socket
	 * @param	thread_fn
	 </haxe_doc>
		</detach>
		<attach public="1" set="method" line="72" static="1">
			<f a="ctx:thread_fn:args">
				<c path="org.zeromq.ZContext"/>
				<f a="::">
					<c path="org.zeromq.ZContext"/>
					<c path="org.zeromq.ZMQSocket"/>
					<d/>
					<e path="Void"/>
				</f>
				<d/>
				<c path="org.zeromq.ZMQSocket"/>
			</f>
			<haxe_doc>
	 * Creates an attached thread (or forked process, for php).
	 * An attached thread/process gets a ctx and a PAIR pipe
	 * back to its parent.  It must monitor its pipe, and exit
	 * if the pipe becomes unreadable.
	 * @param	ctx
	 * @param	thread_fn
	 * @param	args
	 * @return
	 </haxe_doc>
		</attach>
		<bytesToHex set="method" line="109" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
</f></bytesToHex>
		<generateuuid set="method" line="118" static="1"><f a="len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></generateuuid>
		<haxe_doc>
 * ZeroMQ Threading class
 * 
 * Creates neko / cpp Threads, or forks processes (PHP).
 * Using ZThread.fork provides the thread / process with a pre-configured ZMQ PAIR socket
 * for 2-way communication back to the parent.
 </haxe_doc>
	</class>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<_float_of_bytes line="259" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_float_of_bytes>
		<_double_of_bytes line="260" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_double_of_bytes>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<readByte public="1" set="method" line="35"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="44"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="65"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="68"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readAll public="1" set="method" line="75"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" set="method" line="96"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<read public="1" set="method" line="104"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" set="method" line="116"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" set="method" line="124"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" set="method" line="141"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="155"><f a=""><c path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="169"><f a=""><c path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="176"><f a=""><c path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="185"><f a=""><c path="Int"/></f></readUInt16>
		<readInt24 public="1" set="method" line="191"><f a=""><c path="Int"/></f></readInt24>
		<readUInt24 public="1" set="method" line="201"><f a=""><c path="Int"/></f></readUInt24>
		<readInt31 public="1" set="method" line="208"><f a=""><c path="Int"/></f></readInt31>
		<readUInt30 public="1" set="method" line="225"><f a=""><c path="Int"/></f></readUInt30>
		<readInt32 public="1" set="method" line="234"><f a=""><t path="cpp.Int32"/></f></readInt32>
		<readString public="1" set="method" line="242"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>
	An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.
</haxe_doc>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="253" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.
	</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="270" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<typedef path="neko.Sys" params="" file="/usr/lib/haxe/std/cpp/Sys.hx"><c path="cpp.Sys"/></typedef>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/cpp/_std/Reflect.hx">
		<hasField public="1" set="method" line="29" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" set="method" line="33" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" set="method" line="42" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="49" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="56" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="60" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="64" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
		Does not work on Neko platform.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="72" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="79" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="84" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="95" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="org.zeromq.ZMQException" params="" file="./org/zeromq/ZMQException.hx">
		<err public="1" set="null"><e path="org.zeromq.ErrorType"/></err>
		<errNo public="1" set="null"><c path="Int"/></errNo>
		<overriddenStr><c path="String"/></overriddenStr>
		<str public="1" set="method" line="47">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Returns ZMQ - specified human-readable error description
	 * @return
	 </haxe_doc>
		</str>
		<toString public="1" set="method" line="51"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="37"><f a="e:?str">
	<e path="org.zeromq.ErrorType"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * Encapsulates ZMQ Errors
 * Provides the ZMQ - specified errno and a human - readable description
 </haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<class path="org.zeromq.remoting.ZMQSocketProtocol" params="" file="./org/zeromq/remoting/ZMQSocketProtocol.hx">
		<socket public="1"><c path="org.zeromq.ZMQSocket"/></socket>
		<context public="1"><c path="haxe.remoting.Context"/></context>
		<decodeChar set="method" line="86"><f a="c">
	<c path="Int"/>
	<t path="Null"><c path="Int"/></t>
</f></decodeChar>
		<encodeChar set="method" line="105"><f a="c">
	<c path="Int"/>
	<t path="Null"><c path="Int"/></t>
</f></encodeChar>
		<sendRequest public="1" set="method" line="126"><f a="path:params">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></sendRequest>
		<sendAnswer public="1" set="method" line="134"><f a="answer:?isException">
	<d/>
	<e path="Bool"/>
	<e path="Void"/>
</f></sendAnswer>
		<sendMessage public="1" set="method" line="144"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></sendMessage>
		<decodeData public="1" set="dynamic" line="150"><f a="data">
	<c path="String"/>
	<c path="String"/>
</f></decodeData>
		<isRequest public="1" set="method" line="154"><f a="data">
	<c path="String"/>
	<e path="Bool"/>
</f></isRequest>
		<processRequest public="1" set="method" line="162"><f a="data:?onError">
	<c path="String"/>
	<f a="::">
		<c path="Array"><c path="String"/></c>
		<c path="Array"><d/></c>
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></processRequest>
		<processAnswer public="1" set="method" line="184"><f a="data">
	<c path="String"/>
	<d/>
</f></processAnswer>
		<readMessage public="1" set="method" line="192"><f a=""><c path="String"/></f></readMessage>
		<new public="1" set="method" line="81"><f a="sock:ctx">
	<c path="org.zeromq.ZMQSocket"/>
	<c path="haxe.remoting.Context"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
    <p>
    ZeroMQ - based socket protocol for haXe remoting.
    Heavily based on the haxe.remoting.SocketProtocol class implementation.
    </p>
    <p>
	The 0MQ haXe Remoting Socket Protocol is composed of serialized strings converted into byte data exchanges.
    Each message (request or answer) is sent as a single-part zeroMQ message.
    </p>
    <p>
	A request string is composed of the following serialized values :<br />
		- the boolean true for a request<br />
		- an array of strings representing the object+method path<br />
		- an array of parameters<br />
    </p>
    <p>
	A response string is composed of the following serialized values :<br />
		- the boolean false for a response<br />
		- a serialized value representing the result<br />
    </p>
    <p>
	Exceptions are serialized with [serializeException] so they will be thrown immediately
	when they are unserialized.
    </p>
]]></haxe_doc>
	</class>
	<class path="org.zeromq.ZFrame" params="" file="./org/zeromq/ZFrame.hx">
		<ZFRAME_MORE public="1" get="inline" set="null" line="42" static="1"><c path="Int"/></ZFRAME_MORE>
		<ZFRAME_REUSE public="1" get="inline" set="null" line="43" static="1"><c path="Int"/></ZFRAME_REUSE>
		<recvFrame public="1" set="method" line="230" static="1">
			<f a="socket">
				<c path="org.zeromq.ZMQSocket"/>
				<c path="org.zeromq.ZFrame"/>
			</f>
			<haxe_doc>
     * Receives single frame from socket, returns the received frame object, or null if the recv
     * was interrupted. Does a blocking recv, if you want to not block then use
     * recvFrameNoWait()
     * 
     * @param	socket      Socket to read from
     * @return  received frame, else null
     </haxe_doc>
		</recvFrame>
		<recvFrameNoWait public="1" set="method" line="246" static="1">
			<f a="socket">
				<c path="org.zeromq.ZMQSocket"/>
				<c path="org.zeromq.ZFrame"/>
			</f>
			<haxe_doc>
     * Receive a new frame off the socket, Returns newly-allocated frame, or
     * null if there was no input waiting, or if the read was interrupted.
     * @param	socket
     * @return  received frame, else null
     </haxe_doc>
		</recvFrameNoWait>
		<newStringFrame public="1" set="method" line="265" static="1">
			<f a="str">
				<c path="String"/>
				<c path="org.zeromq.ZFrame"/>
			</f>
			<haxe_doc><![CDATA[
	 * Creates a new ZFrame object from a given string.
	 * 
	 * Can be used in combination with send method for a one-line command:
     * <pre>
	 * import org.zeromq.ZFrame;
	 * using  org.zeromq.ZFrame;
	 * ...
	 * ZFrame.newStringFrame("Hello".send(mySocket));
	 * var str = "World";
	 * str.newStringFrame().send(mySocket);
	 * </pre>
	 ]]></haxe_doc>
		</newStringFrame>
		<more public="1" set="null">
			<e path="Bool"/>
			<haxe_doc> More flag, from last frame read </haxe_doc>
		</more>
		<data public="1" set="null">
			<c path="haxe.io.Bytes"/>
			<haxe_doc> Message blob for frame </haxe_doc>
		</data>
		<destroy public="1" set="method" line="67">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
     * Destructor
     </haxe_doc>
		</destroy>
		<recv set="method" line="73"><f a="socket">
	<c path="org.zeromq.ZMQSocket"/>
	<c path="haxe.io.Bytes"/>
</f></recv>
		<recvNoWait set="method" line="90"><f a="socket">
	<c path="org.zeromq.ZMQSocket"/>
	<c path="haxe.io.Bytes"/>
</f></recvNoWait>
		<send public="1" set="method" line="112">
			<f a="socket:?flags">
				<c path="org.zeromq.ZMQSocket"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Sends frame to socket, destroy after sending unless ZFRAME_REUSE is set
     * @param	socket
     * @param	flags
     </haxe_doc>
		</send>
		<size public="1" get="inline" set="null" line="127">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
     * Returns byte size of frame, if set, else 0
     * @return
     </haxe_doc>
		</size>
		<duplicate public="1" set="method" line="137">
			<f a=""><c path="org.zeromq.ZFrame"/></f>
			<haxe_doc>
     * Creates a new frame that duplicates an existing frame
     * @return  A duplicates ZFrame object
     </haxe_doc>
		</duplicate>
		<equals public="1" set="method" line="146">
			<f a="other">
				<c path="org.zeromq.ZFrame"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
     * Returns true if both frames have identical size and data
     * @param	other
     * @return
     </haxe_doc>
		</equals>
		<reset public="1" set="method" line="162">
			<f a="data">
				<c path="haxe.io.Bytes"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Set new contents for frame
     * @param	data    New data bytes for this frame
     </haxe_doc>
		</reset>
		<strhex public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>
     * Return frame data encoded as printable hex string
     * @return
     </haxe_doc>
		</strhex>
		<streq public="1" set="method" line="191">
			<f a="str">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
     * Returns true if frame body is equivalent to given string
     * @param	str
     * @return  true if matches, else false
     </haxe_doc>
		</streq>
		<hasData public="1" set="method" line="200">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
     * Convenience method to ascertain if this frame contains some message data
     * @return
     </haxe_doc>
		</hasData>
		<toString public="1" set="method" line="209">
			<f a=""><c path="String"/></f>
			<haxe_doc>
     * Returns string representation of frame's data bytes
     * @return
     </haxe_doc>
		</toString>
		<new public="1" set="method" line="56">
			<f a="?data">
				<c path="haxe.io.Bytes"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Constructor.
     * Copies message data into zframe object
     * @param	data
     </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * <p>
 * The ZFrame class provides methods to send and receive single message
 * frames across 0MQ sockets. A 'frame' corresponds to one underlying zmq_msg_t in the libzmq code.
 * When you read a frame from a socket, the more() method indicates if the frame is part of an 
 * unfinished multipart message.  The send() method normally destroys the frame, but with the ZFRAME_REUSE flag, you can send
 * the same frame many times. Frames are binary, and this class has no special support for text data.
 * </p>
 * <p>
 * Based on <a href="http://github.com/zeromq/czmq/blob/master/src/zframe.c">zframe.c</a> in czmq
 * </p>
 ]]></haxe_doc>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<_float_bytes line="253" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_float_bytes>
		<_double_bytes line="254" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_double_bytes>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<writeByte public="1" set="method" line="37"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="41"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="64"><f a=""><e path="Void"/></f></flush>
		<close public="1" set="method" line="67"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="70"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<write public="1" set="method" line="77"><f a="s">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></write>
		<writeFullBytes public="1" set="method" line="88"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeFullBytes>
		<writeFloat public="1" set="method" line="96"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method" line="108"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeInt8 public="1" set="method" line="120"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeInt16 public="1" set="method" line="126"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeUInt16 public="1" set="method" line="131"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt24 public="1" set="method" line="142"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt24>
		<writeUInt24 public="1" set="method" line="147"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt24>
		<writeInt31 public="1" set="method" line="160"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt30 public="1" set="method" line="177"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt32 public="1" set="method" line="192"><f a="x">
	<t path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<prepare public="1" set="method" line="212">
			<f a="nbytes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.
	</haxe_doc>
		</prepare>
		<writeInput public="1" set="method" line="215"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeInput>
		<writeString public="1" set="method" line="237"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<haxe_doc>
	An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.
</haxe_doc>
	</class>
	<class path="cpp.io.FileOutput" params="" file="/usr/lib/haxe/std/cpp/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close line="64" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<unknown/>
</f></file_close>
		<file_seek line="65" static="1"><f a="::">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="66" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
</f></file_tell>
		<file_flush line="68" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<unknown/>
</f></file_flush>
		<file_write line="69" static="1"><f a=":::">
	<t path="cpp.io.FileHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_write>
		<file_write_char line="70" static="1"><f a=":">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
	<unknown/>
</f></file_write_char>
		<__f><t path="cpp.io.FileHandle"/></__f>
		<writeByte public="1" set="method" line="39" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="43" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="47" override="1"><f a=""><e path="Void"/></f></flush>
		<close public="1" set="method" line="51" override="1"><f a=""><e path="Void"/></f></close>
		<seek public="1" set="method" line="56"><f a="p:pos">
	<c path="Int"/>
	<e path="cpp.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<tell public="1" set="method" line="60"><f a=""><c path="Int"/></f></tell>
		<new public="1" set="method" line="35"><f a="f">
	<t path="cpp.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Use [cpp.io.File.write] to create a [FileOutput]
</haxe_doc>
	</class>
	<class path="org.zeromq.ZSocket" params="" file="./org/zeromq/ZSocket.hx">
		<DYNFROM public="1" get="inline" set="null" line="57" static="1">
			<c path="Int"/>
			<haxe_doc> This port range is defined by IANA for dynamic or private ports.
     * Used when choosing port for dynamic binding.
     </haxe_doc>
		</DYNFROM>
		<DYNTO public="1" get="inline" set="null" line="58" static="1"><c path="Int"/></DYNTO>
		<isType public="1" set="method" line="67" static="1">
			<f a="socket:type">
				<c path="org.zeromq.ZMQSocket"/>
				<e path="org.zeromq.SocketType"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
     * Tests type of socket
     * @param	socket  Socket to test
     * @param	type    SocketType enum to test for
     * @return  true if socket is of given type, else false, else null if could not determine socket type
     </haxe_doc>
		</isType>
		<bindEndpoint public="1" set="method" line="92" static="1">
			<f a="socket:protocol:interf:?port">
				<c path="org.zeromq.ZMQSocket"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
     * Bind a socket to an endpoint given by a specified protoype, interface address and port number
     * If the port is specified as null, or not specified, binds to any free port from DYNFROM to DYNTO
     * and returns the actual port number used. Otherwise asserts that the bind succeeded with the 
     * specified port number. Always return the port number if successful.
     * @param	socket      ZMQSocket to bind to
     * @param	protocol    Network protocol "tcp", "inproc" etc
     * @param	interf      Bind address "foo.com", "127.0.0.3"
     * @param	port        (optional) Port number
     * @return  Port number if bind successful, else -1
     </haxe_doc>
		</bindEndpoint>
		<connectEndpoint public="1" set="method" line="125" static="1">
			<f a="socket:protocol:interf:?port">
				<c path="org.zeromq.ZMQSocket"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Connects a socket to a defined endpoint
     * 
     * @param	socket      ZMQSocket to bind to
     * @param	protocol    Network protocol "tcp", "inproc" etc
     * @param	interf      Bind address "foo.com", "127.0.0.3"
     * @param	port        Port number
     </haxe_doc>
		</connectEndpoint>
		<haxe_doc><![CDATA[
 * <p>
 * ZSocket provides higher-level ZMQSocket socket helper static methods.
 * </p>
 * <p>
 * <pre>
 * import org.zeromq.ZMQ;
 * using org.zeromq.ZSocket;
 * ...
 * var output = ctx.createSocket(ZMQ_PUSH);
 * var input = ctx.createSocket(ZMQ_PULL);
 * 
 * // Bind to a tcp port on localhost
 * var port = output.bind("tcp", "*", "5560");
 * 
 * // Connect
 * input.connect("tcp", "localhost", "5560");
 * </pre>
 * 
 * <p>
 * Based on the <a href="http://github.com/zeromq/czmq/blob/master/src/zsocket.c">zsocket.c</a> source code in the czmq project.
 * </p>
 * 
 ]]></haxe_doc>
	</class>
	<typedef path="org.zeromq.PollItemT" params="" file="./org/zeromq/ZLoop.hx" module="org.zeromq.ZLoop">
		<a>
			<socket><c path="org.zeromq.ZMQSocket"/></socket>
			<event><c path="Int"/></event>
		</a>
		<haxe_doc><![CDATA[
 * (c) 2011 Richard J Smith
 *
 * This file is part of hxzmq
 *
 * hxzmq is free software; you can redistribute it and/or modify it under
 * the terms of the Lesser GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * hxzmq is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Lesser GNU General Public License for more details.
 *
 * You should have received a copy of the Lesser GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ]]></haxe_doc>
	</typedef>
	<typedef path="org.zeromq._ZLoop.PollerT" params="" file="./org/zeromq/ZLoop.hx" private="1" module="org.zeromq.ZLoop"><a>
	<pollItem><t path="org.zeromq.PollItemT"/></pollItem>
	<handler><f a=":">
	<c path="org.zeromq.ZLoop"/>
	<c path="org.zeromq.ZMQSocket"/>
	<c path="Int"/>
</f></handler>
</a></typedef>
	<typedef path="org.zeromq._ZLoop.TimerT" params="" file="./org/zeromq/ZLoop.hx" private="1" module="org.zeromq.ZLoop"><a>
	<when><c path="Float"/></when>
	<times><c path="Int"/></times>
	<handler><f a=":">
	<c path="org.zeromq.ZLoop"/>
	<d/>
	<c path="Int"/>
</f></handler>
	<delay><c path="Float"/></delay>
	<args><d/></args>
</a></typedef>
	<class path="org.zeromq.ZLoop" params="" file="./org/zeromq/ZLoop.hx">
		<newPoller set="method" line="319" static="1">
			<f a="item:handler">
				<t path="org.zeromq.PollItemT"/>
				<f a=":">
					<c path="org.zeromq.ZLoop"/>
					<c path="org.zeromq.ZMQSocket"/>
					<c path="Int"/>
				</f>
				<t path="org.zeromq._ZLoop.PollerT"/>
			</f>
			<haxe_doc>
     * Creates a new Poller T anonymous object
     * @param	item
     * @param	handler
     * @return
     </haxe_doc>
		</newPoller>
		<newTimer set="method" line="333" static="1">
			<f a="delay:times:handler:args">
				<c path="Float"/>
				<c path="Int"/>
				<f a=":">
					<c path="org.zeromq.ZLoop"/>
					<d/>
					<c path="Int"/>
				</f>
				<d/>
				<t path="org.zeromq._ZLoop.TimerT"/>
			</f>
			<haxe_doc>
     * Creates a new TimerT anonymous object
     * @param	delay
     * @param	times
     * @param	handler
     * @return
     </haxe_doc>
		</newTimer>
		<verbose public="1">
			<e path="Bool"/>
			<haxe_doc> Turns on verbose trace logging </haxe_doc>
		</verbose>
		<pollers>
			<c path="List"><t path="org.zeromq._ZLoop.PollerT"/></c>
			<haxe_doc> List of registered pollers </haxe_doc>
		</pollers>
		<timers>
			<c path="List"><t path="org.zeromq._ZLoop.TimerT"/></c>
			<haxe_doc> List of registered timers </haxe_doc>
		</timers>
		<zombies>
			<c path="List"><d/></c>
			<haxe_doc> List of timer argument objects to kill </haxe_doc>
		</zombies>
		<poller>
			<c path="org.zeromq.ZMQPoller"/>
			<haxe_doc> Internal ZMQPoller object that holds the actual pollset used when querying socket state </haxe_doc>
		</poller>
		<dirty>
			<e path="Bool"/>
			<haxe_doc> True if list of pollers and timers are different to pollset held within the poller object </haxe_doc>
		</dirty>
		<log>
			<f a="">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc> Logger function used in verbose mode. Set during ZLoop construction </haxe_doc>
		</log>
		<destroy public="1" set="method" line="106">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
     * Destructor
     </haxe_doc>
		</destroy>
		<registerTimer public="1" set="method" line="126">
			<f a="delay:times:handler:?args">
				<c path="Float"/>
				<c path="Int"/>
				<f a=":">
					<c path="org.zeromq.ZLoop"/>
					<d/>
					<c path="Int"/>
				</f>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
     * Register a timer that expires after some delay and repeats some number of times. At each expiry, will call the handler.
     * To run a timer forever, use 0 times. Returns true if OK, false if there was an error
     * @param	delay       Number of milliseconds to delay event for
     * @param	times       Number of times to repeat, else 0 for forever
     * @param	handler     Handler function
	 * @param   args		Arguments passed to timer handler function
     * @return  true if OK, else false
     </haxe_doc>
		</registerTimer>
		<unregisterTimer public="1" set="method" line="137">
			<f a="args">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Cancel all timers for a specific handler function argument object
	 * @param	args
	 </haxe_doc>
		</unregisterTimer>
		<registerPoller public="1" set="method" line="156">
			<f a="item:handler">
				<t path="org.zeromq.PollItemT"/>
				<f a=":">
					<c path="org.zeromq.ZLoop"/>
					<c path="org.zeromq.ZMQSocket"/>
					<c path="Int"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
     * Register pollitem with the reactor. When the pollitem is ready, will call
     * the handler.  Returns true if OK, else false.
     * If you register a pollitem more than once, each instance will invoke its
     * corresponding handler.
     * @param	item        PollItem (socket & polled-for event)
     * @param	handler     Handler function, receives polled ZMQSocket object
     * @return  true if OK, else false
     ]]></haxe_doc>
		</registerPoller>
		<unregisterPoller public="1" set="method" line="172">
			<f a="item">
				<t path="org.zeromq.PollItemT"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes a previously registered poller from the reactor, specified by a socket.
	 * If multiple poll items exist for the same socket, this method removes ALL of them from the reactor.
	 * @param	item
	 </haxe_doc>
		</unregisterPoller>
		<start public="1" set="method" line="196">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
     * Start the reactor. Takes control of the thread and returns when the 0MQ
     * context is terminated or the process is interrupted, or any event handler returns -1.
     * Event handlers may register new sockets and timers, and cancel sockets.
     * @return Returns 0 if interrupted, -1 if cancelled by a handler
     </haxe_doc>
		</start>
		<rebuildPollset set="method" line="284">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
     * Rebuilds pollset held within the poller object from list of registered pollers
     </haxe_doc>
		</rebuildPollset>
		<ticklessTimer set="method" line="296">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
     * Calculate timeout between now and next timed event
     * @return  Number of milliseconds between now and next timed event
     </haxe_doc>
		</ticklessTimer>
		<new public="1" set="method" line="89">
			<f a="?logger">
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Constructor.
	 * Generic Type parameter defines argument types passed to registered timer function handler methods
     * @param logger    (Optional). Provide a logging function that accepts zloop trace log entries generated when verbose = true.
     </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * <p>
 * The ZLoop class provides an event-driven reactor pattern. The reactor handles socket readers not writers,
 * and once-off or repeated timers.  its resolution is 1 msec. It uses a tickless timer to reduce CPU interrupts in
 * inactive processes.
 * </p>
 * <p>
 * Note that at present, it only supports 0MQ sockets; polling of haXe Socket objects is not supported. 
 * </p>
 * <p>
 * Based on <a href="http://github.com/zeromq/czmq/blob/master/src/zloop.c">zloop.c</a> in czmq
 * </p>
 ]]></haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="46">
			<f a="?x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="57">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="73">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="87">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="Array"><d/></c></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="cpp.io.FileInput" params="" file="/usr/lib/haxe/std/cpp/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<file_eof line="79" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<e path="Bool"/>
</f></file_eof>
		<file_read line="81" static="1"><f a=":::">
	<t path="cpp.io.FileHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_read>
		<file_read_char line="82" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
</f></file_read_char>
		<file_close line="84" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<unknown/>
</f></file_close>
		<file_seek line="85" static="1"><f a="::">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="86" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
</f></file_tell>
		<__f><t path="cpp.io.FileHandle"/></__f>
		<readByte public="1" set="method" line="39" override="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="50" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="61" override="1"><f a=""><e path="Void"/></f></close>
		<seek public="1" set="method" line="66"><f a="p:pos">
	<c path="Int"/>
	<e path="cpp.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<tell public="1" set="method" line="70"><f a=""><c path="Int"/></f></tell>
		<eof public="1" set="method" line="75"><f a=""><e path="Bool"/></f></eof>
		<new public="1" set="method" line="35"><f a="f">
	<t path="cpp.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Use [cpp.io.File.read] to create a [FileInput]
</haxe_doc>
	</class>
	<class path="org.zeromq.ZMQContext" params="" file="./org/zeromq/ZMQContext.hx">
		<_instance static="1"><c path="org.zeromq.ZMQContext"/></_instance>
		<_hasInstance static="1"><e path="Bool"/></_hasInstance>
		<instance public="1" set="method" line="108" static="1">
			<f a="?ioThreads">
				<c path="Int"/>
				<c path="org.zeromq.ZMQContext"/>
			</f>
			<haxe_doc>
	 * Returns a global ZMQContext instance, or null
	 * 
	 * @param	?ioThreads = 1
	 </haxe_doc>
		</instance>
		<_hx_zmq_construct line="120" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></_hx_zmq_construct>
		<_hx_zmq_term line="121" static="1"><f a="">
	<d/>
	<unknown/>
</f></_hx_zmq_term>
		<contextHandle public="1" set="null">
			<d/>
			<haxe_doc> Opaque data used by hxzmq driver </haxe_doc>
		</contextHandle>
		<closed public="1" set="null">
			<e path="Bool"/>
			<haxe_doc> Records if context has been terminated </haxe_doc>
		</closed>
		<term public="1" set="method" line="65">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Close or terminate the context
	 * 
	 * This can be called to close the context by hand. If this is not
     * called, the context will automatically be closed when it is
     * garbage collected.
	 </haxe_doc>
		</term>
		<socket public="1" set="method" line="84">
			<f a="type">
				<e path="org.zeromq.SocketType"/>
				<c path="org.zeromq.ZMQSocket"/>
			</f>
			<haxe_doc>
	 * Create a Socket associated with this Context
	 * @param	socketType	The socket type which can be any of the ZMQ socket types
	 * @return  A ZMQSocket object
	 </haxe_doc>
		</socket>
		<poller public="1" set="method" line="96">
			<f a=""><c path="org.zeromq.ZMQPoller"/></f>
			<haxe_doc>
	 * Convenience method to create a ZMQPoller object.
	 * Raises a ENOTSUP ZMQException if context is closed
	 * @return	A ZMQPoller object
	 </haxe_doc>
		</poller>
		<new public="1" set="method" line="44">
			<f a="ioThreads">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a ZMQ Context
	 * 
	 * Can throw EINVAL if invalid number of iothreads requested
	 * 
	 * See: http://api.zeromq.org/master:zmq-init
	 </haxe_doc>
		</new>
	</class>
	<class path="org.zeromq.ZMQPoller" params="" file="./org/zeromq/ZMQPoller.hx">
		<_hx_zmq_poll line="220" static="1"><f a="::">
	<c path="Array"><d/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Int"/>
	<t path="org.zeromq.PollResult"/>
</f></_hx_zmq_poll>
		<revents public="1" set="null">
			<c path="Array"><c path="Int"/></c>
			<haxe_doc>
     * Provides the last-polled set of rececived events
     </haxe_doc>
		</revents>
		<pollItems><c path="List"><t path="org.zeromq.PollSocketEventTuple"/></c></pollItems>
		<getSize public="1" set="method" line="53"><f a=""><c path="Int"/></f></getSize>
		<registerSocket public="1" set="method" line="62">
			<f a="socket:event">
				<c path="org.zeromq.ZMQSocket"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Adds a socket to the internal list of polled sockets
	 * @param	socket	A ZMQScxket object
	 * @param	event	Bitmasked Int for polled events (ZMQ_POLLIN, ZMQ_POLLOUT)
	 </haxe_doc>
		</registerSocket>
		<unregisterSocket public="1" set="method" line="79">
			<f a="socket">
				<c path="org.zeromq.ZMQSocket"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Removes a previously registered socket
	 * @param	socket
	 * @return
	 </haxe_doc>
		</unregisterSocket>
		<unregisterAllSockets public="1" set="method" line="100">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Removes all current registered sockets
	 </haxe_doc>
		</unregisterAllSockets>
		<poll public="1" set="method" line="109">
			<f a="?timeout">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Poll a set of 0MQ sockets, 
	 * @param	?timeout	Timeout in microseconds, or 0 to return immediately, or -1 to block indefintely (default)
	 * @return	how many objects signalled, or 0 if none, or -1 if failure
	 </haxe_doc>
		</poll>
		<pollin public="1" set="method" line="189">
			<f a="s">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Test if the s'th registered socket has a registered POLLIN event.
	 * Call this after a poll() method call to test the results.
	 * 
	 * @param	s	Valid s parameter range from 1 to revents.length
	 * @return		True if specified registered socket has a current POLLIN event, else False
	 </haxe_doc>
		</pollin>
		<pollout public="1" set="method" line="203">
			<f a="s">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Test if the s'th registered socket has a registered POLLOUT event.
	 * Call this after a poll() method call to test the results.
	 * 
	 * @param	s	Valid s parameter range from 1 to revents.length
	 * @return		True if specified registered socket has a current POLLOUT event, else False
	 </haxe_doc>
		</pollout>
		<noevents public="1" set="method" line="215">
			<f a="s">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Test of the s'th registered socket has no received polled events
	 * @param	s	Valid s parameter range from 1 to revents.length
	 * @return		True if no received polled events on the socket
	 </haxe_doc>
		</noevents>
		<new public="1" set="method" line="46">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Encapsulates ZMQ Poller functions.
 * 
 * Statefull class, maintaining a set of sockets to poll, events to poll for
 </haxe_doc>
	</class>
	<typedef path="org.zeromq.PollSocketEventTuple" params="" file="./org/zeromq/ZMQPoller.hx" module="org.zeromq.ZMQPoller"><a>
	<_socket><c path="org.zeromq.ZMQSocket"/></_socket>
	<_event><c path="Int"/></_event>
</a></typedef>
	<typedef path="org.zeromq.PollResult" params="" file="./org/zeromq/ZMQPoller.hx" module="org.zeromq.ZMQPoller"><a>
	<_revents><c path="Array"><c path="Int"/></c></_revents>
	<_ret><c path="Int"/></_ret>
</a></typedef>
	<typedef path="cpp.Int32" params="" file="/usr/lib/haxe/std/cpp/CppInt32__.hx" module="cpp.CppInt32__"><c path="cpp.CppInt32__"/></typedef>
	<class path="cpp.CppInt32__" params="" file="/usr/lib/haxe/std/cpp/CppInt32__.hx" extern="1">
		<make public="1" set="method" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<t path="cpp.Int32"/>
</f></make>
		<ofInt public="1" set="method" static="1"><f a="x">
	<c path="Int"/>
	<t path="cpp.Int32"/>
</f></ofInt>
		<toInt public="1" set="method" static="1"><f a="x">
	<t path="cpp.Int32"/>
	<c path="Int"/>
</f></toInt>
		<add public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></add>
		<sub public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></sub>
		<mul public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></mul>
		<div public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></div>
		<mod public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></mod>
		<shl public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<c path="Int"/>
	<t path="cpp.Int32"/>
</f></shl>
		<shr public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<c path="Int"/>
	<t path="cpp.Int32"/>
</f></shr>
		<ushr public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<c path="Int"/>
	<t path="cpp.Int32"/>
</f></ushr>
		<and public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></and>
		<or public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></or>
		<xor public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></xor>
		<neg public="1" set="method" static="1"><f a="a">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></neg>
		<complement public="1" set="method" static="1"><f a="a">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></complement>
		<compare public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<c path="Int"/>
</f></compare>
	</class>
	<typedef path="haxe.Int32" params="" file="/usr/lib/haxe/std/haxe/Int32.hx"><c path="cpp.CppInt32__"/></typedef>
	<class path="org.zeromq.ZMQSocket" params="" file="./org/zeromq/ZMQSocket.hx">
		<_hx_zmq_construct_socket line="468" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></_hx_zmq_construct_socket>
		<_hx_zmq_close line="469" static="1"><f a="">
	<d/>
	<unknown/>
</f></_hx_zmq_close>
		<_hx_zmq_bind line="470" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></_hx_zmq_bind>
		<_hx_zmq_connect line="471" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></_hx_zmq_connect>
		<_hx_zmq_send line="472" static="1"><f a="::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<unknown/>
</f></_hx_zmq_send>
		<_hx_zmq_rcv line="473" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
</f></_hx_zmq_rcv>
		<_hx_zmq_setintsockopt line="474" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<d/>
	<unknown/>
</f></_hx_zmq_setintsockopt>
		<_hx_zmq_setint64sockopt line="475" static="1"><f a=":::">
	<d/>
	<c path="Int"/>
	<unknown/>
	<unknown/>
	<unknown/>
</f></_hx_zmq_setint64sockopt>
		<_hx_zmq_setbytessockopt line="476" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<d/>
	<unknown/>
</f></_hx_zmq_setbytessockopt>
		<_hx_zmq_getintsockopt line="477" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></_hx_zmq_getintsockopt>
		<_hx_zmq_getint64sockopt line="478" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></_hx_zmq_getint64sockopt>
		<_hx_zmq_getbytessockopt line="479" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></_hx_zmq_getbytessockopt>
		<closed public="1" set="null">
			<e path="Bool"/>
			<haxe_doc> Records if socket has been closed </haxe_doc>
		</closed>
		<context public="1" set="null">
			<c path="org.zeromq.ZMQContext"/>
			<haxe_doc>
	 * Hold reference to context associated with socket, to stop it being garbage collected
	 </haxe_doc>
		</context>
		<_socketHandle public="1" set="null">
			<d/>
			<haxe_doc> Opaque data used by hxzmq driver </haxe_doc>
		</_socketHandle>
		<type public="1" set="null">
			<e path="org.zeromq.SocketType"/>
			<haxe_doc>
     * Holds type of socket
     </haxe_doc>
		</type>
		<close public="1" set="method" line="87">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Close the socket
	 * 
	 * This can be called to close the socket by hand. If this is not
	 * called, the socket will automatically be closed when it is
	 * garbage collected.
	 </haxe_doc>
		</close>
		<bind public="1" set="method" line="114">
			<f a="addr">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Bind a socket to an address
	 * 
	 * This causes the socket to listen on a network port. Sockets on the
	 * other side of this connection will use ``Socket.connect(addr)`` to
	 * connect to this socket.
	 * 
	 * @param	addr	The address string.
	 * 				This has the form 'protocol://interface:port',
	 * 				for example 'tcp://127.0.0.1:5555'. Protocols supported are
	 * 				tcp, upd, pgm, inproc and ipc. If the address is unicode, it is
	 * 				encoded to utf-8 first.
	 </haxe_doc>
		</bind>
		<connect public="1" set="method" line="143">
			<f a="addr">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Connect to a remote ZMQ socket
	 * 
	 * @param	addr	The address string
	 * 				This has the form 'protocol://interface:port',
	 * 				for example 'tcp://127.0.0.1:5555'. Protocols supported are
	 * 				tcp, upd, pgm, inproc and ipc. 
	 </haxe_doc>
		</connect>
		<setsockopt public="1" set="method" line="182">
			<f a="option:optval">
				<e path="org.zeromq.SocketOptionsType"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set socket options.
	 * 
	 * See the ZMQ documentation for details on specific options: 
	 * http://api.zeromq.org/master:zmq-setsockopt
	 * 
	 * C Parameter type     optval haXe type expected
     * =================    ==========================
     * int                  Int
     * int64_t, uint64_t    ZMQInt64Type (if neko or cpp)
     *                      Int (if php - will be 64bits on 64bit platforms, else 32 bit)
     * binary               haxe.io.Bytes
     * 
	 * @param	option		SocketOptionsType (defined in ZMQ.hx)
	 * @param	optval		Either Int or String or Bytes
	 </haxe_doc>
		</setsockopt>
		<getsockopt public="1" set="method" line="273">
			<f a="option">
				<e path="org.zeromq.SocketOptionsType"/>
				<d/>
			</f>
			<haxe_doc>
	 * Return a previously set socket option
	 * 
	 * @param	option
	 * @return
	 </haxe_doc>
		</getsockopt>
		<sendMsg public="1" set="method" line="371">
			<f a="data:?flags">
				<c path="haxe.io.Bytes"/>
				<e path="org.zeromq.SendReceiveFlagType"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Send a message on this socket
	 * 
	 * This queues the message to be sent by the IO thread at a later time.
	 * 
	 * @param	data	The content of the message
	 * @param	?flags	Any supported SocketFlag DONTWAIT, SNDMORE
	 </haxe_doc>
		</sendMsg>
		<recvMsg public="1" set="method" line="403">
			<f a="?flags">
				<e path="org.zeromq.SendReceiveFlagType"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>
	 * Receive a message on this socket
	 * 
	 * Will return either a message, null (if DONTWAIT was used and there was no data received) or a ZMQException
	 * 
	 * @param	?flags
	 * @return
	 </haxe_doc>
		</recvMsg>
		<hasReceiveMore public="1" set="method" line="443">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Convenience method to test if socket has more parts of a multipart message to read
	 * @return
	 </haxe_doc>
		</hasReceiveMore>
		<equals public="1" set="method" line="458">
			<f a="other">
				<c path="org.zeromq.ZMQSocket"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Performs a target-specific equality test to another ZMQSocket instance
	 * @param	other
	 * @return
	 </haxe_doc>
		</equals>
		<new public="1" set="method" line="66">
			<f a="context:type">
				<c path="org.zeromq.ZMQContext"/>
				<e path="org.zeromq.SocketType"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * 
	 * Creates a new ZMQ socket
	 * @param	context		A ZMQ Context previously created
	 * @param	type		A ZMQ socket type
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A 0MQ socket
 * 
 * These objects will generally be created via the socket() method of a ZMQContext object.
 * 
 * Class based on code from pyzmq project
 * See: https://github.com/zeromq/pyzmq/blob/master/zmq/core/socket.pyx
 </haxe_doc>
	</class>
	<typedef path="neko.io.FileOutput" params="" file="/usr/lib/haxe/std/cpp/io/FileOutput.hx"><c path="cpp.io.FileOutput"/></typedef>
	<typedef path="neko.vm.ThreadHandle" params="" file="/usr/lib/haxe/std/cpp/vm/Thread.hx" module="neko.vm.Thread"><t path="cpp.vm.ThreadHandle"/></typedef>
	<typedef path="neko.vm.Thread" params="" file="/usr/lib/haxe/std/cpp/vm/Thread.hx"><c path="cpp.vm.Thread"/></typedef>
	<class path="Date" params="" file="/usr/lib/haxe/std/cpp/_std/Date.hx">
		<now public="1" set="method" line="55" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" set="method" line="59" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="65" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<mSeconds><c path="Float"/></mSeconds>
		<getTime public="1" set="method" line="35">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1" set="method" line="39">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method" line="41">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method" line="43">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method" line="45">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method" line="47">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method" line="49">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1" set="method" line="51">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method" line="53">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="31"><f a="year:month:day:hour:min:sec">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="211" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="239" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="278" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="51"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" set="method" line="65"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" set="method" line="93"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="112"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" set="method" line="148"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<getData public="1" get="inline" set="null" line="207"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="IntIter" params="" file="/usr/lib/haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="org.zeromq.ZContext" params="" file="./org/zeromq/ZContext.hx">
		<shadow public="1" set="method" line="141" static="1">
			<f a="ctx">
				<c path="org.zeromq.ZContext"/>
				<c path="org.zeromq.ZContext"/>
			</f>
			<haxe_doc>
     * Creates new shadow context.
     * Shares same underlying ZMQContext but has own list of managed sockets, io thread count etc.
     * @param   ctx     Original ZContext to create shadow of.
     * @return  New ZContext object
     </haxe_doc>
		</shadow>
		<context public="1" set="null">
			<c path="org.zeromq.ZMQContext"/>
			<haxe_doc> Reference to underlying ZMQContext object </haxe_doc>
		</context>
		<sockets public="1" set="null">
			<c path="List"><c path="org.zeromq.ZMQSocket"/></c>
			<haxe_doc> List of sockets managed by this ZContext </haxe_doc>
		</sockets>
		<ioThreads public="1">
			<c path="Int"/>
			<haxe_doc> Number of io threads allocated to this context, default 1 </haxe_doc>
		</ioThreads>
		<linger public="1">
			<c path="Int"/>
			<haxe_doc> Linger timeout, default 0 </haxe_doc>
		</linger>
		<main public="1">
			<e path="Bool"/>
			<haxe_doc> Indicates if context object owned by main thread </haxe_doc>
		</main>
		<destroy public="1" set="method" line="83">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
     * Destructor. Call this to gracefully close context and managed sockets
     </haxe_doc>
		</destroy>
		<createSocket public="1" set="method" line="104">
			<f a="type">
				<e path="org.zeromq.SocketType"/>
				<c path="org.zeromq.ZMQSocket"/>
			</f>
			<haxe_doc>
     * Creates a new managed socket within this ZContext context.
       * Use this to get automatic management of the socket at shutdown
     * @param	type
     * @return
     </haxe_doc>
		</createSocket>
		<destroySocket public="1" set="method" line="122">
			<f a="s">
				<c path="org.zeromq.ZMQSocket"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Destroys managed socket within this context.
     * @param	s   Socket to remove
     </haxe_doc>
		</destroySocket>
		<new public="1" set="method" line="66">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
     * Constructor
     </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * <p>
 * ZContext provides a higher-level zeroMQ context management class.
 * It is inspired by the <a href="http://github.com/zeromq/czmq/blob/master/src/zctx.c">zctx.c</a> source code in the czmq project.
 * </p>
 * <p>
 * The ZContext class wraps haXe ZMQContext objects, which in turn wrap native 0MQ contexts.
 * It manages open sockets in the context and automatically closes these before terminating the context. 
 * It provides a simple way to set the linger timeout on sockets, and configure contexts for number of I/O threads. 
 * Sets-up signal (interrrupt) handling for the process.
 * </p>
 * <p>
 * The ZContext class has these main features:<br />
 * 1. Tracks all open sockets and automatically closes them before calling zmq_term(). This avoids an infinite wait on open sockets.<br />
 * 2. Automatically configures sockets with a ZMQ_LINGER timeout you can define, and which defaults to zero. The default behaviour of ZContext is therefore like 0MQ/2.0, immediate termination with loss of any pending messages. You can set any linger timeout you like by calling the zctx_set_linger() method.<br />
 * 3. Moves the iothreads configuration to a separate method, so that default usage is 1 I/O thread. Lets you configure this value.<br />
 * 4. Sets up signal (SIGINT and SIGTERM) handling so that blocking calls such as zmq_recv() and zmq_poll() will return when the user presses Ctrl-C.<br />
 * 
 * </p>
 ]]></haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="org.zeromq.ZMQDevice" params="" file="./org/zeromq/ZMQDevice.hx">
		<_hx_zmq_device line="71" static="1"><f a="::">
	<c path="Int"/>
	<d/>
	<d/>
	<unknown/>
</f></_hx_zmq_device>
		<new public="1" set="method" line="41">
			<f a="type:frontend:backend">
				<e path="org.zeromq.DeviceType"/>
				<c path="org.zeromq.ZMQSocket"/>
				<c path="org.zeromq.ZMQSocket"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 * Creates a new ZMQ device and immediately starts its in-built loop.
	 * Will continue unless process is interrupted, when it returns a ETERM ZMQ_Exception.
	 * @param	type		A valid DeviceType
	 * @param   frontend	Front end socket, bound or connected to by clients
	 * @param   backend     Back end socket, bound or connected to workers
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Wraps ZMQ zmq_device method call.
 * Creates in-built ZMQ devices that run in the current thread of execution
 </haxe_doc>
	</class>
	<typedef path="haxe.TypeResolver" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx" module="haxe.Unserializer"><a>
	<resolveEnum set="method"><f a="name">
	<c path="String"/>
	<c path="Enum"><d/></c>
</f></resolveEnum>
	<resolveClass set="method"><f a="name">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></resolveClass>
</a></typedef>
	<class path="Type" params="" file="/usr/lib/haxe/std/cpp/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="39" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="50" static="1">
			<f a="o">
				<d/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="56" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="60" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="66" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="70" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="77" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="84" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="90" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="94" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="100" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="106" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="110" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="114" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="118" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="134" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="138" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="142" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="147" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="34" static="1"><t path="haxe.TypeResolver"/></DEFAULT_RESOLVER>
		<BASE64 line="36" static="1"><c path="String"/></BASE64>
		<CODES line="39" static="1"><c path="Array"><c path="Int"/></c></CODES>
		<initCodes set="method" line="41" static="1"><f a=""><c path="Array"><c path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="351" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a single value and return it.
	</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><c path="Int"/></pos>
		<length><c path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="76"><f a="r">
	<t path="haxe.TypeResolver"/>
	<e path="Void"/>
</f></setResolver>
		<getResolver public="1" set="method" line="86"><f a=""><t path="haxe.TypeResolver"/></f></getResolver>
		<get get="inline" set="null" line="90"><f a="p">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<readDigits set="method" line="94"><f a=""><c path="Int"/></f></readDigits>
		<unserializeObject set="method" line="119"><f a="o">
	<a/>
	<e path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="134"><f a="edecl:tag">
	<c path="Enum"><d/></c>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="155"><f a=""><d/></f></unserialize>
		<new public="1" set="method" line="64"><f a="buf">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.remoting.Context" params="" file="/usr/lib/haxe/std/haxe/remoting/Context.hx">
		<share public="1" set="method" line="58" static="1"><f a="name:obj">
	<c path="String"/>
	<a/>
	<c path="haxe.remoting.Context"/>
</f></share>
		<objects><c path="Hash"><a>
	<rec><e path="Bool"/></rec>
	<obj><d/></obj>
</a></c></objects>
		<addObject public="1" set="method" line="35"><f a="name:obj:?recursive">
	<c path="String"/>
	<a/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addObject>
		<call public="1" set="method" line="39"><f a="path:params">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/cpp/_std/Std.hx">
		<is public="1" set="method" line="27" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="31" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" set="method" line="35" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="39" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="43" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="47" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>
		Creates an [Array] from an [Iterable]
	</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>
		Creates a [List] from an [Iterable]
	</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>
		Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.
	</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>
		Similar to [map], but also pass an index for each item iterated.
	</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.
	</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if at least one element of the iterable is found by using the specific function.
	</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if all elements of the iterable have the specified property defined by [f].
	</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Call the function 'f' on all elements of the [Iterable] 'it'.
	</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>
		Return the list of elements matching the function 'f'
	</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>
		Functional 'fold' using an [Iterable]
	</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Count the number of elements in an [Iterable] having [pred] returning true.
	</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an iterable does not contain any element.
	</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.
	</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>
		Returns a list containing all items of 'a' followed by all items of 'b'
	</haxe_doc>
		</concat>
		<haxe_doc>
	The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.
</haxe_doc>
	</class>
	<typedef path="cpp.vm.ThreadHandle" params="" file="/usr/lib/haxe/std/cpp/vm/Thread.hx" module="cpp.vm.Thread"><d/></typedef>
	<class path="cpp.vm.Thread" params="" file="/usr/lib/haxe/std/cpp/vm/Thread.hx">
		<current public="1" set="method" line="49" static="1">
			<f a=""><c path="cpp.vm.Thread"/></f>
			<haxe_doc>
		Returns the current thread.
	</haxe_doc>
		</current>
		<create public="1" set="method" line="56" static="1">
			<f a="callb">
				<f a=""><e path="Void"/></f>
				<c path="cpp.vm.Thread"/>
			</f>
			<haxe_doc>
		Creates a new thread that will execute the [callb] function, then exit.
	</haxe_doc>
		</create>
		<readMessage public="1" set="method" line="65" static="1">
			<f a="block">
				<e path="Bool"/>
				<d/>
			</f>
			<haxe_doc>
		Reads a message from the thread queue. If [block] is true, the function
		blocks until a message is available. If [block] is false, the function
		returns [null] if no message is available.
	</haxe_doc>
		</readMessage>
		<handle><t path="cpp.vm.ThreadHandle"/></handle>
		<sendMessage public="1" set="method" line="41">
			<f a="msg">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Send a message to the thread queue. This message can be readed by using [readMessage].
	</haxe_doc>
		</sendMessage>
		<__compare set="method" line="69"><f a="t">
	<a><handle set="null"><t path="cpp.vm.ThreadHandle"/></handle></a>
	<unknown/>
</f></__compare>
		<new set="method" line="34"><f a="h">
	<t path="cpp.vm.ThreadHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Serializer" params="" file="/usr/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="34" static="1">
			<e path="Bool"/>
			<haxe_doc>
		If the values you are serializing can contain
		circular references or objects repetitions, you should
		set USE_CACHE to true to prevent infinite loops.
	</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="40" static="1">
			<e path="Bool"/>
			<haxe_doc>
		Use constructor indexes for enums instead of names.
		This is less reliable but more compact.
	</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="42" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="409" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize a single value and return the string.
	</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="Hash"><c path="Int"/></c></shash>
		<scount><c path="Int"/></scount>
		<useCache public="1"><e path="Bool"/></useCache>
		<useEnumIndex public="1"><e path="Bool"/></useEnumIndex>
		<toString public="1" set="method" line="60"><f a=""><c path="String"/></f></toString>
		<serializeString set="method" line="94"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="113"><f a="v">
	<unknown/>
	<e path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="150"><f a="v">
	<unknown/>
	<e path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="158"><f a="v">
	<d/>
	<e path="Void"/>
</f></serialize>
		<serializeException public="1" set="method" line="390"><f a="e">
	<d/>
	<e path="Void"/>
</f></serializeException>
		<new public="1" set="method" line="51"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.zeromq.ZMsg" params="" file="./org/zeromq/ZMsg.hx">
		<recvMsg public="1" set="method" line="351" static="1">
			<f a="socket">
				<c path="org.zeromq.ZMQSocket"/>
				<c path="org.zeromq.ZMsg"/>
			</f>
			<haxe_doc>
     * Receives message from socket, returns ZMsg object or null if the
     * recv was interrupted. Does a blocking recv, if you want not to block then use
     * the ZLoop class or ZMQPoller to check for socket input before receiving.
     * @param	socket
     * @return
     </haxe_doc>
		</recvMsg>
		<newStringMsg public="1" set="method" line="380" static="1">
			<f a="data">
				<c path="String"/>
				<c path="org.zeromq.ZMsg"/>
			</f>
			<haxe_doc>
     * Simple method that adds a single supplied string to a new ZMsg, and returns the message object
     * @param	data
     * @return
     </haxe_doc>
		</newStringMsg>
		<save public="1" set="method" line="399" static="1">
			<f a="msg:file">
				<c path="org.zeromq.ZMsg"/>
				<t path="neko.io.FileOutput"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
     * Save message to an open file, return true if OK, else false
     * 
     * Data saved as:
     * 4 bytes: number of frames
     * For every frame:
     *  4 bytes: byte size of frame
     *  + bytes: frame data bytes
     * 
     * @param	msg
     * @param	file
     * @return
     </haxe_doc>
		</save>
		<load public="1" set="method" line="430" static="1">
			<f a="file:?msg">
				<t path="neko.io.FileInput"/>
				<c path="org.zeromq.ZMsg"/>
				<c path="org.zeromq.ZMsg"/>
			</f>
			<haxe_doc>
     * Load / append a ZMsg from an open file.
     * Create a new message if null message provided.
     * 
     * @param	file
     * @param	?msg
     * @return
     </haxe_doc>
		</load>
		<frames><c path="List"><c path="org.zeromq.ZFrame"/></c></frames>
		<destroy public="1" set="method" line="74">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
     * Destructor.
     * Destroys all ZFrames stored in ZMsg
     </haxe_doc>
		</destroy>
		<size public="1" set="method" line="85">
			<f a=""><c path="Int"/></f>
			<haxe_doc> Return number of frames in message </haxe_doc>
		</size>
		<contentSize public="1" set="method" line="97">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
     * Return number of bytes contained in all the frames in this message
     * @return
     </haxe_doc>
		</contentSize>
		<add public="1" set="method" line="111">
			<f a="frame">
				<c path="org.zeromq.ZFrame"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Add a ZFrame to end of list
     * @param	frame   ZFrame to add to list
     * @throws ZMQException if frame is null
     </haxe_doc>
		</add>
		<wrap public="1" set="method" line="122">
			<f a="frame">
				<c path="org.zeromq.ZFrame"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Push frame plus empty frame to front of message, before first frame.
	 * Message takes ownership of frame, will destroy it when message is sent.
	 </haxe_doc>
		</wrap>
		<unwrap public="1" set="method" line="135">
			<f a=""><c path="org.zeromq.ZFrame"/></f>
			<haxe_doc>
	 * Pop frame off front of message, caller now owns frame.
	 * If next frame is empty, pops and destroys that empty frame
	 * (e.g. useful when unwrapping ROUTER socket envelopes)
	 * @return	Unwrapped frame
	 </haxe_doc>
		</unwrap>
		<remove public="1" set="method" line="155">
			<f a="frame">
				<c path="org.zeromq.ZFrame"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
     * Removes an existing frame from the message.
     * Does not destroy the removed frame.
     * @param	frame   ZFrame to remove
     * @return  true if frame is found and removed, else false
     </haxe_doc>
		</remove>
		<iterator public="1" set="method" line="166">
			<f a=""><t path="Iterator"><c path="org.zeromq.ZFrame"/></t></f>
			<haxe_doc>
     * Returns an iterator over the ZFrame list within the ZMsg
     * @return
     </haxe_doc>
		</iterator>
		<filter public="1" set="method" line="179">
			<f a="f">
				<f a="">
					<c path="org.zeromq.ZFrame"/>
					<e path="Bool"/>
				</f>
				<c path="org.zeromq.ZMsg"/>
			</f>
			<haxe_doc>
     * Returns a new ZMsg object containing only those ZFrames from this message
     * where f(x) is true
     * @param	f
     * @return  Filtered ZMsg object, else null if this message contains no frame list (ie has been destroyed)
     </haxe_doc>
		</filter>
		<first public="1" set="method" line="195">
			<f a=""><c path="org.zeromq.ZFrame"/></f>
			<haxe_doc>
     * Returns last frame in message, else null if frame list is empty or invalid (destroyed)
     * @return
     </haxe_doc>
		</first>
		<isEmpty public="1" set="method" line="206">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
     * returns True if the ZMsg has no frames, else false
     * @return
     </haxe_doc>
		</isEmpty>
		<last public="1" set="method" line="214">
			<f a=""><c path="org.zeromq.ZFrame"/></f>
			<haxe_doc>
     * Returns last frame in message, else null if frame list is empty or invalid (destroyed)
     * @return
     </haxe_doc>
		</last>
		<pop public="1" set="method" line="226">
			<f a=""><c path="org.zeromq.ZFrame"/></f>
			<haxe_doc>
     * Removes first frame from message, if any. Returns frame or null.
     * Caller now owns frame and must destroy() it when finished with it.
     * @return
     </haxe_doc>
		</pop>
		<push public="1" set="method" line="238">
			<f a="frame">
				<c path="org.zeromq.ZFrame"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Push frame to the front of the message, before all the other frames.
     * ZMsg object takes ownership of the frame, will destroy it when message is sent.
     * @param	frame
     </haxe_doc>
		</push>
		<pushString public="1" set="method" line="251">
			<f a="str">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Pushes string as new ZFrame at front of ZMsg frame list
     * @param	str
     </haxe_doc>
		</pushString>
		<addString public="1" set="method" line="262">
			<f a="str">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Adds string as new ZFrame at end of ZMsg frame list
     * @param	str
     </haxe_doc>
		</addString>
		<popString public="1" set="method" line="274">
			<f a=""><c path="String"/></f>
			<haxe_doc>
     * Pop frame off top of message, returns as a String, else null if
     * no frames in message, or if popped frame has no data.
     * @return
     </haxe_doc>
		</popString>
		<duplicate public="1" set="method" line="290">
			<f a=""><c path="org.zeromq.ZMsg"/></f>
			<haxe_doc><![CDATA[
     * Creates copy of this message, also copying all contained frames & their data
     * @return  Copied ZMsg object, or null if this message contains an invalid (destroyed) frame list.
     ]]></haxe_doc>
		</duplicate>
		<send public="1" set="method" line="306">
			<f a="socket">
				<c path="org.zeromq.ZMQSocket"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Send message to socket, destroys after sending.  If the message has no
     * frames, sends nothing but destroys the message anyhow.
     * @param	socket
     </haxe_doc>
		</send>
		<toString public="1" set="method" line="328">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Returns msg contents as a readable string
	 * @return
	 </haxe_doc>
		</toString>
		<new public="1" set="method" line="66">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
     * Constructor
     </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * <p>The ZMsg class provides methods to send and receive multipart messages
 * across 0MQ sockets. This class provides a list-like container interface,
 * with methods to work with the overall container.  ZMsg messages are
 * composed of zero or more ZFrame objects.
 * </p>
 * <p>
 * <pre>
 * // Send a simple single-frame string message on a ZMQSocket "output" socket object
 * ZMsg.newStringMsg("Hello").send(output);
 * 
 * // Add several frames into one message
 * var msg:ZMsg = new ZMsg();
 * for (i in 0 ... 10) {
 *     msg.addString("Frame" + i);
 * }
 * msg.send(output);
 * 
 * // Receive message from ZMQSocket "input" socket object and iterate over frames
 * var receivedMessage = ZMsg.recvMsg(input);
 * for (f in receivedMessage) {
 *     // Do something with frame f (of type ZFrame)
 * }
 * </pre>
 * </p>
 * <p>
 * Based on <a href="http://github.com/zeromq/czmq/blob/master/src/zmsg.c">zmsg.c</a> in czmq
 * </p>
 ]]></haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="80">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="88">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="98">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="193">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="212">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="228">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<typedef path="neko.io.FileInput" params="" file="/usr/lib/haxe/std/cpp/io/FileInput.hx"><c path="cpp.io.FileInput"/></typedef>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/cpp/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	This exception is raised when reading while data is no longer available in the [Input].
</haxe_doc>
	</class>
	<class path="IntHash" params="T" file="/usr/lib/haxe/std/cpp/_std/IntHash.hx">
		<h><d/></h>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="50">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="55">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="60">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.
</haxe_doc>
	</class>
	<class path="Class" params="T" file="/usr/lib/haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<typedef path="neko.Lib" params="" file="/usr/lib/haxe/std/cpp/Lib.hx"><c path="cpp.Lib"/></typedef>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="cpp.Sys" params="" file="/usr/lib/haxe/std/cpp/Sys.hx">
		<args public="1" set="method" line="5" static="1"><f a=""><c path="Array"><c path="String"/></c></f></args>
		<getEnv public="1" set="method" line="9" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></getEnv>
		<putEnv public="1" set="method" line="16" static="1"><f a="s:v">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></putEnv>
		<sleep public="1" set="method" line="20" static="1"><f a="seconds">
	<c path="Float"/>
	<e path="Void"/>
</f></sleep>
		<setTimeLocale public="1" set="method" line="24" static="1"><f a="loc">
	<c path="String"/>
	<e path="Bool"/>
</f></setTimeLocale>
		<getCwd public="1" set="method" line="28" static="1"><f a=""><c path="String"/></f></getCwd>
		<setCwd public="1" set="method" line="32" static="1"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></setCwd>
		<systemName public="1" set="method" line="36" static="1"><f a=""><c path="String"/></f></systemName>
		<escapeArgument public="1" set="method" line="40" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" set="method" line="54" static="1"><f a="cmd:?args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="Int"/>
</f></command>
		<exit public="1" set="method" line="63" static="1"><f a="code">
	<c path="Int"/>
	<e path="Void"/>
</f></exit>
		<time public="1" set="method" line="67" static="1"><f a=""><c path="Float"/></f></time>
		<cpuTime public="1" set="method" line="71" static="1"><f a=""><c path="Float"/></f></cpuTime>
		<executablePath public="1" set="method" line="75" static="1"><f a=""><c path="String"/></f></executablePath>
		<environment public="1" set="method" line="79" static="1"><f a=""><c path="Hash"><c path="String"/></c></f></environment>
		<get_env line="91" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></get_env>
		<put_env line="92" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></put_env>
		<_sleep line="93" static="1"><f a="">
	<c path="Float"/>
	<unknown/>
</f></_sleep>
		<set_time_locale line="94" static="1"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></set_time_locale>
		<get_cwd line="95" static="1"><f a=""><c path="String"/></f></get_cwd>
		<set_cwd line="96" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></set_cwd>
		<sys_string line="97" static="1"><f a=""><c path="String"/></f></sys_string>
		<sys_command line="98" static="1"><f a="">
	<c path="String"/>
	<c path="Int"/>
</f></sys_command>
		<sys_exit line="99" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></sys_exit>
		<sys_time line="100" static="1"><f a=""><c path="Float"/></f></sys_time>
		<sys_cpu_time line="101" static="1"><f a=""><c path="Float"/></f></sys_cpu_time>
		<sys_exe_path line="102" static="1"><f a=""><c path="String"/></f></sys_exe_path>
		<sys_env line="103" static="1"><f a=""><c path="Array"><c path="String"/></c></f></sys_env>
	</class>
	<class path="haxe.io.Unsigned_char__" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx" module="haxe.io.BytesData" extern="1"/>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><c path="haxe.io.Unsigned_char__"/></c></typedef>
	<class path="Hash" params="T" file="/usr/lib/haxe/std/cpp/_std/Hash.hx">
		<__Internal><d/></__Internal>
		<set public="1" set="method" line="33">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="37">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="41">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="45">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="61">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="75">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
</haxe>